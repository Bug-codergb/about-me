import{_ as t,c as a,o as r,b0 as i}from"./chunks/framework.yGdRLqI0.js";const h=JSON.parse('{"title":"Vite与Webpack关键区别","description":"","frontmatter":{},"headers":[],"relativePath":"engineering/difference/index.md","filePath":"engineering/difference/index.md"}'),l={name:"engineering/difference/index.md"};function n(o,e,d,c,s,b){return r(),a("div",null,e[0]||(e[0]=[i('<h1 id="vite与webpack关键区别" tabindex="-1">Vite与Webpack关键区别 <a class="header-anchor" href="#vite与webpack关键区别" aria-label="Permalink to &quot;Vite与Webpack关键区别&quot;">​</a></h1><h2 id="核心架构差异" tabindex="-1">核心架构差异 <a class="header-anchor" href="#核心架构差异" aria-label="Permalink to &quot;核心架构差异&quot;">​</a></h2><table><tr><th></th><th>Webpack</th><th>Vite</th></tr><tr><td>底层引擎</td><td> 开发阶段：ESBuild + 原生 ESM<br> 生产阶段：Rollup </td><td> 自研打包引擎（js打包器） </td></tr><tr><td>模块加载方式</td><td> 开发：原生 ESM（浏览器直接解析）<br> 生产：Rollup 打包 </td><td> 全程打包（生成虚拟模块依赖图） </td></tr></table><ul><li><strong>关键区别</strong>： <ul><li><strong>开发模式：</strong><ul><li>Vite：利用浏览器原生支持 ES Modules，直接按需编译文件，无需打包。→ 启动快（秒级），HMR 快（仅更新单个文件）。</li><li>Webpack：启动时构建完整的依赖图并打包所有文件。→ 启动慢（项目越大越慢），HMR 需要重新分析依赖。</li></ul></li><li><strong>生产模式：</strong><ul><li>Vite：使用 Rollup 进行打包（Rollup 以 Tree Shaking 高效著称）。</li><li>Webpack：自研打包机制，功能更灵活但配置复杂。</li></ul></li></ul></li></ul><h2 id="项目搭建" tabindex="-1">项目搭建 <a class="header-anchor" href="#项目搭建" aria-label="Permalink to &quot;项目搭建&quot;">​</a></h2><ul><li><a href="https://github.com/Bug-codergb/gb-webpack/tree/master/gb-vite-client" target="_blank" rel="noreferrer">Vite :</a> 通过基本配置从0到1搭建项目</li><li><a href="https://github.com/Bug-codergb/gb-webpack/tree/master/gb-webpack-client" target="_blank" rel="noreferrer">Webpack:</a> 通过基本配置从0到1搭建项目</li></ul>',6)]))}const p=t(l,[["render",n]]);export{h as __pageData,p as default};
