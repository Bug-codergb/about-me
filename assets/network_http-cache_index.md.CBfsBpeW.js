import{_ as t,c as i,o,b0 as a}from"./chunks/framework.yGdRLqI0.js";const _=JSON.parse('{"title":"Http缓存策略","description":"","frontmatter":{},"headers":[],"relativePath":"network/http-cache/index.md","filePath":"network/http-cache/index.md"}'),l={name:"network/http-cache/index.md"};function r(c,e,n,d,s,p){return o(),i("div",null,e[0]||(e[0]=[a('<h1 id="http缓存策略" tabindex="-1">Http缓存策略 <a class="header-anchor" href="#http缓存策略" aria-label="Permalink to &quot;Http缓存策略&quot;">​</a></h1><ol><li>缓存的原理是在首次请求后保存一份请求资源的响应副本，当用户再次发起相同的请求，如果判断缓存命中则拦截请求，将之前请求响应的副本返还给用户，从而避免重新向服务器发起资源请求。</li></ol><h3 id="http缓存" tabindex="-1">Http缓存 <a class="header-anchor" href="#http缓存" aria-label="Permalink to &quot;Http缓存&quot;">​</a></h3><p>http缓存分为<strong>强制缓存</strong>和<strong>协商缓存</strong></p><ul><li><strong>强制缓存</strong><ul><li>如果浏览器判断所请求的目标资源有效命中，则直接从强制缓存中返回请求响应，无需与服务器进行任何通信</li><li><code>expires</code>和<code>cache-control</code></li><li><code>expires</code>会在浏览器发送请求时，与当前本地时间戳进行比较，如果本地时间小于expires则缓存未失效。反之失效，重新请求（对本地时间戳过分依赖，如果本地时间和服务端时间不一致，或者对客户端时间主动修改，缓存过期时间判断会出现差错）</li><li><code>cache-control</code>可以通过设置maxage,no-chache和no-store</li><li>public和private 表示是否可以有代理服务器进行缓存</li></ul></li><li><strong>协商缓存</strong><ul><li>使用本地缓存之前，向服务器发送一次GET请求，与之协商当前浏览器本地缓存是否过期。</li><li><code>last-modified</code>（响应头） 和 <code>if-modified-since</code>(请求头)</li><li>服务器发送GET请求，请求缓存有效性的协商GET请求中包含一个if-since-modified字段，其值正是上次响应头中last-modified中的字段值</li></ul></li></ul>',5)]))}const f=t(l,[["render",r]]);export{_ as __pageData,f as default};
