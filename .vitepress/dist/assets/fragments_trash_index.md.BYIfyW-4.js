import{_ as e,c as t,o as r,a_ as o}from"./chunks/framework.YI5SBq3X.js";const u=JSON.parse('{"title":"js的垃圾回收机制","description":"","frontmatter":{},"headers":[],"relativePath":"fragments/trash/index.md","filePath":"fragments/trash/index.md"}'),s={name:"fragments/trash/index.md"};function n(i,a,l,d,h,_){return r(),t("div",null,a[0]||(a[0]=[o('<h1 id="js的垃圾回收机制" tabindex="-1">js的垃圾回收机制 <a class="header-anchor" href="#js的垃圾回收机制" aria-label="Permalink to &quot;js的垃圾回收机制&quot;">​</a></h1><h2 id="标记-清除算法" tabindex="-1">标记-清除算法 <a class="header-anchor" href="#标记-清除算法" aria-label="Permalink to &quot;标记-清除算法&quot;">​</a></h2><p>从根对象(全局对象、当前函数调用栈等)开始，遍历所有可达对象，并标记为&quot;活动的&quot;，遍历堆内存，回收所有未被标记的对象内存</p><h2 id="引用计数算法" tabindex="-1">引用计数算法 <a class="header-anchor" href="#引用计数算法" aria-label="Permalink to &quot;引用计数算法&quot;">​</a></h2><p>通过统计每个对象的引用次数,当引用计数为0时，对象会被回收</p><h2 id="主要区别" tabindex="-1">主要区别 <a class="header-anchor" href="#主要区别" aria-label="Permalink to &quot;主要区别&quot;">​</a></h2><ul><li><strong>标记-清除</strong>：看对象是否能从根对象访问到</li><li><strong>引用计数</strong>：只看对象被多少其他对象引用</li></ul>',7)]))}const m=e(s,[["render",n]]);export{u as __pageData,m as default};
